searchState.loadedDescShard("rs_tfhe", 0, "FFT Processor Module for TFHE\nLookup Table (LUT) support for programmable bootstrapping\nParallelization abstraction layer for rs-tfhe\nConvert a Vector of bits to a number\nEncrypt the bits of the type as an array of LweSample …\nRepresent the bits of the byte as an array of boolean …\nTrait for bootstrapping strategies\nPerform a full bootstrap with key switching\nPerform bootstrap without key switching\nGet the default bootstrap strategy\nLUT (Lookup Table) bootstrapping implementation\nGet the name of this bootstrap strategy\nLUT-based programmable bootstrapping strategy\nPerform programmable bootstrapping with a function\nPerform programmable bootstrapping with a pre-computed …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new LUT bootstrap strategy\nVanilla bootstrap implementation\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new vanilla bootstrap strategy\nFFT Processor trait for negacyclic polynomial …\nGeneric batch FFT for any power-of-2 size N\nGeneric batch IFFT for any power-of-2 size N\nGeneric inverse FFT for any power-of-2 size N Input: N f64 …\nReturns the argument unchanged.\nGeneric forward FFT for any power-of-2 size N Input: N …\nCalls <code>U::from(self)</code>.\nExtended FFT Processor - Hybrid High-Performance …\nCreate a new FFT processor for polynomials of size n\nGeneric negacyclic polynomial multiplication for any …\nExtended FFT processor with rustfft optimization\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGates struct that uses a configurable bootstrap strategy\nConvenience function for AND gate using default bootstrap\nHomomorphic AND gate\nConvenience function for AND_NY gate using default …\nHomomorphic AND-NOT-Y gate (a AND NOT b)\nConvenience function for AND_YN gate using default …\nHomomorphic AND-Y-NOT gate (a AND NOT b)\nBatch AND operation - process multiple gates in parallel …\nBatch NAND operation - process multiple gates in parallel\nBatch NOR operation - optimized with batch_blind_rotate\nBatch OR operation - optimized with batch_blind_rotate\nBatch XNOR operation - optimized with batch_blind_rotate\nBatch XOR operation - optimized with batch_blind_rotate\nGet the name of the bootstrap strategy being used\nConvenience function for CONSTANT\nCreate a constant encrypted value (no bootstrapping needed)\nConvenience function for COPY\nCopy a ciphertext (no bootstrapping needed)\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nConvenience function for MUX gate using default bootstrap\nHomomorphic MUX gate (a ? b : c)\nConvenience function for naive MUX gate using default …\nHomomorphic MUX gate (naive version)\nConvenience function for NAND gate using default bootstrap\nHomomorphic NAND gate\nCreate a new Gates instance with the default bootstrap …\nConvenience function for NOR gate using default bootstrap\nHomomorphic NOR gate\nConvenience function for NOT gate\nHomomorphic NOT gate (no bootstrapping needed)\nConvenience function for OR gate using default bootstrap\nHomomorphic OR gate\nConvenience function for OR_NY gate using default bootstrap\nHomomorphic OR-NOT-Y gate (NOT a OR b)\nConvenience function for OR_YN gate using default bootstrap\nHomomorphic OR-Y-NOT gate (a OR NOT b)\nCreate a Gates instance with a specific bootstrap strategy\nConvenience function for XNOR gate using default bootstrap\nHomomorphic XNOR gate\nConvenience function for XOR gate using default bootstrap\nHomomorphic XOR gate\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMessage encoding for lookup tables\nLookup table generator for programmable bootstrapping\nLookup table implementation for programmable bootstrapping\nEncoder for different message spaces in programmable …\nDecode a torus value back to an integer message\nDecode a torus value to a boolean (for binary messages)\nEncode an integer message into a torus value\nEncode with a custom scale factor\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNumber of possible messages (e.g., 2 for binary, 4 for …\nCreate a new encoder with the given message modulus\nScaling factor for encoding\nCreate a new encoder with custom message modulus and scale\nGenerator for creating lookup tables from functions\nReturns the argument unchanged.\nGenerate a lookup table from a function\nGenerate a lookup table and write to the provided output\nGenerate a lookup table with custom message modulus and …\nGenerate a lookup table from a function that returns Torus …\nGenerate a lookup table with full control over Torus values\nCalls <code>U::from(self)</code>.\nGet the lookup table size\nGet the message modulus\nSwitch the modulus of x from Torus (2^32) to …\nCreate a new LUT generator\nGet the polynomial degree\nCreate a new LUT generator with custom scale\nLookup table for programmable bootstrapping\nClear the lookup table (sets all coefficients to 0)\nCopy values from another lookup table\nReturns the argument unchanged.\nCreate a lookup table from an existing TRLWE polynomial\nCalls <code>U::from(self)</code>.\nCheck if the lookup table is empty (all coefficients are …\nCreate a new lookup table\nGet a reference to the underlying polynomial\nPolynomial encoding the function values\nGet a mutable reference to the underlying polynomial\nConfiguration for parallel execution\nTrait for parallelization backends\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nNumber of threads (None = automatic)\nParallel map over a slice with a function\nParallel map over a slice with indexed function\nRayon-based implementation of the Railgun trait\nCreate a custom Rayon-based parallelization backend\nStack size per thread (in bytes)\nExecute a closure with a custom parallel configuration\nRayon-based parallelization backend\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new Rayon backend with default configuration\nCreate a new Rayon backend with custom configuration\nDefault security parameters (128-bit)\n110-bit security parameters (balanced, original TFHE)\n128-bit security parameters (default, high security, …\n80-bit security parameters (performance-optimized)\nUint1 parameters (1-bit binary/boolean, messageModulus=2)\nUint2 parameters (2-bit messages, messageModulus=4)\nUint3 parameters (3-bit messages, messageModulus=8)\nUint4 parameters (4-bit messages, messageModulus=16)\nUint5 parameters (5-bit messages, messageModulus=32) - …\nUint6 parameters (6-bit messages, messageModulus=64)\nUint7 parameters (7-bit messages, messageModulus=128)\nUint8 parameters (8-bit messages, messageModulus=256)\nSecurity parameter set containing all TFHE parameters\nTFHE Security Parameter Selection\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCompatibility module for existing code that expects the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet a description of the current security level\nThe resulting type after applying the operation.\nThe resulting type after applying the operation.\nDecrypt a message using LWE message decoding for …\nEncrypt a message using LWE message encoding for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBatch blind rotate - process multiple blind rotations in …\nBatch blind rotate with custom parallelization backend\nBlind rotation with custom test vector (for LUT …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")